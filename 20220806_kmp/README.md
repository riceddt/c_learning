kmp算法的c++实现

作用：

kmp算法是用来查找某一目标字符串T中是否有输入的模式字符串P，如果有，可返回模式字符串在目标字符串中的位置。

分析：

区别于暴力破解法，kmp算法中，指向目标字符串的数组下标只会向后移动，指向模式字符串的数组下标根据自身的字符重复情况，确定下标的移动，移动量由next[]数组给出。

k=next[k]解析：

假设当前数组p的内容是："XYXYaXYXYcd"；

经过前面的循环比较，已经找到了匹配的字符XYXY，

即k=4，j=9，next[j]=k=4, 然后发现p[k]=a，p[j]=c， 二者不相同，所以进入else分支。

为了求出next[j+1]，j位置不能动，必须调整后缀字符串的起始位置，起始位置应大于5，指向Y或者更右边的字符，这意味着可能的匹配长途会变小，即k变小。

但是无论k怎么变，还是用p的前缀来匹配p的后缀，即**用前缀XYXY的前缀去匹配后缀XYXY的后缀**（目的是利用已匹配的结果来找前后缀中新的公共字符串，如果中有和后缀XYXY的后缀相匹配的字符串，那么前缀XYXY的前缀的后一个字符如果能和后缀XYXY的后缀的后一个字符匹配的话，即P[k]==p[j]，那么就连上了，next[j+1]也就可以求出）。**等效于在模式字符串XYXY（起个名字叫t）里面在进行前缀匹配后缀**，成功的把对p的求k过程，递归的转换成了对t的求k过程。

而字符串t的k值已经早计算过了：即在j=4的时候，所以有k=next[k]=next[4]=2，这就是k来历，不存在其他的中间值。

